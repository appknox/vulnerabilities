
Generally, all mobile code is susceptible to reverse engineering. Some apps are more susceptible than others. Code written in languages / frameworks that allow for dynamic introspection at runtime (Java, .NET, Objective C, Swift) are particularly at risk for reverse engineering. Detecting susceptibility to reverse engineering is fairly straight forward. First, decrypt the app store version of the app (if binary encryption is applied). Code will be susceptible if it is fairly easy to understand the app’s controlflow path, string table, and any pseudocode/source-code generated by these tools.

Bytecode obfuscation consists of multiple complementary techniques
that can help create a layered defense against reverse engineering and
tampering. Some typical examples of obfuscation techniques include:

- <b>Renaming</b> to alter the name of methods and variables to make
    the decompiled source much harder for a human to understand.
- <b>Control Flow Obfuscation</b>creates conditional, branching, and
    iterative constructs that produce valid executable logic, but yield
    non-deterministic semantic results when decompiled.
- <b>String Encryption</b> hides strings in the executable and only
    restores their original value when needed
- <b>Instruction Pattern Transformation</b> converts common
    instructions to other, less obvious constructs potential confusing
    decompliers.
- <b>Dummy Code Insertion</b> inserts code that does not affect the
    program’s logic, but breaks decompilers or makes reverse-engineered
    code harder to analyze.
- <b>Unused Code and Metadata Removal</b> prunes out debug,
    non-essential metadata and used code from applications to reduce the
    information available to an attacker.
